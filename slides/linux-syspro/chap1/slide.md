---
marp: true
theme: gaia

---

# 1章 概要および主要概念 補足資料

<style>
{
font-size: 22px;
}
</style>

- Linus Torvalds、LinuxとGit(Linuxを分散開発するために必要だった)を作った人
- 気性が荒いことで有名

[![Image from Gyazo](https://i.gyazo.com/81a46bb3d011bc133514477914987640.jpg)](https://gyazo.com/81a46bb3d011bc133514477914987640)

---

## 1.1 システムプログラミング

**X Window System**（エックスウィンドウシステム、別称：「X11」・「X」など）とは、ビットマップディスプレイ上でウィンドウシステムを提供する表示プロトコルである(Wikipediaより)

[![Image from Gyazo](https://i.gyazo.com/3d9a7cf27ef93d84c737e466e656c08e.png)](https://gyazo.com/3d9a7cf27ef93d84c737e466e656c08e)

---

### 1.1.1 システムコール

システムコールとは、ユーザー空間からOSに何らかの動作やリソースを要求するための、カーネル機能を呼び出す物

- read(): ファイルディスクリプターから読み込む
- write(): ファイルディスクリプター (file descriptor) に書き込む
- get_thread_area(): スレッド局所記憶領域を取り出す
- set_tid_Address(): thread IDのポインタを設定する ?

---

### (脱線)ファイルディスクリプタとは？

> ファイル（への通り道）に割り振られる番号で、ファイルを識別するための目印

 ([「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word14383.html)) より


>プログラムが特定のファイルを指定して「開く」操作を行うと、カーネル内のファイルテーブルと呼ばれる領域に対応する項目が作成され、対象ファイルのストレージ上での位置（パス）、ファイル内の現在の操作位置などの情報が記録される。

>このテーブル内での当該ファイルの識別番号がファイルディスクリプタで、以降はプログラムからファイルディスクリプタを指定して、どのファイルへの操作なのかをカーネルに伝達する。

>通常、ファイルディスクリプタは0から順番に未使用の最も小さい値が与えられるようになっており、プログラム上では整数型の変数などとして扱われる。ただし、番号によっては固定的に特殊な対象を表す場合があり、一般的には「0」は標準入力（stdin）、「1」は標準出力（stdout）、「2」は標準エラー出力（stderr）としてプログラムの実行中は常に開いた状態になっている。

([IT用語辞典 e-Words](https://e-words.jp/w/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF.html))

---

### (脱線) スレッド局所記憶領域(thread local storage, TLS)

- グローバル変数がプロセスごとに割り当てる変数
- スレッドローカル変数はスレッドごとの領域に割り当てられています。その領域をスレッドローカルストレージという
    - errno: errnoは、マルチスレッドという概念が導入される前のもの。スレッドローカルにしないと各スレッドでのシステムコール呼び出しの結果で errno が上書きされるという事故に繋がります

---

#### 1.1.1.1 システムコールの発行 (アセンブリ言語 Ubuntu20.04)

<style>
pre > code {
  font-size: 17px;
}
</style>

```assembly
.globl _start
_start:
    /* $の後が数字なら数字、文字なら変数。%はレジスタ */
    movl $4,%eax   /* write システムコール番号 */
    movl $1,%ebx   /* 書き込み先 - 標準出力 */
    movl $msg,%ecx /* 書き込むメッセージ */
    movl $13,%edx  /* メッセージの長さ */
    int $0x80      /* システムコール実行 割り込み実行 */

    movl $1,%eax /* システムコール終了番号 */
    movl $0,%ebx /* 終了状態 */
    int $0x80    /* システムコール終了 割り込み実行 */

.data
    msg: .asciz "Hello,World\n"
```

```sh
➜ ~ as -o main.o main.S
➜ ~ ld -o main.out main.o
➜ ~ ./main.out
hello,World
➜ ~
```

- [アセンブリコードで「int0x80」とはどういう意味ですか？](https://codehero.jp/assembly/1817577/what-does-int-0x80-mean-in-assembly-code)
- [さくっとアセンブリ入門 hello,world編](https://rabbitfoot141.hatenablog.com/entry/2016/05/01/124410)

---

#### 1.1.1.1 システムコールの発行 (C言語)

```c
#include<unistd.h>

int main(){
  const void *string = "Hello,World!\n";
  write(1, string, 13);
  return 0;
}
```

```sh
➜ ~ gcc write.c
➜ ~ ./a.out
Hello World!
➜ ~
```

---

#### (おまけ) 1.1.1.1 システムコールの発行

```assembly
int main(){
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
  const void *string = "Hello Write!\n";
   c:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 13 <main+0x13>
  13:   48 89 45 f8             mov    %rax,-0x8(%rbp)
  write(1, string, 13);
  17:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  1b:   ba 0d 00 00 00          mov    $0xd,%edx
  20:   48 89 c6                mov    %rax,%rsi
  23:   bf 01 00 00 00          mov    $0x1,%edi
  28:   e8 00 00 00 00          callq  2d <main+0x2d>
  return 0;
  2d:   b8 00 00 00 00          mov    $0x0,%eax
}
  32:   c9                      leaveq
  33:   c3                      retq
```

---

### 1.1.2 Cライブラリ

- 本を読む

---

### 1.1.3 Cコンパイラ

- 本を読む

---

## 1.2 API と ABI

- 本を読む
- API（application programming interface）
- ABI（application binary interface）です。
- API も ABI も異なる種類のソフトウェア間のインタフェースを定義するものです。

---

### 1.2.1 API

- APIとは、ソフトウェア間のソースレベルでのインタフェースを定義したもの
- 他のソフトウェアから呼び出し可能なインタフェース(通常は関数)の標準セットを定義し、抽象化したものです。
- 双方のソフトウェアがAPIにしたがっている場合に限り、動作は保証され、ソースレベルの互換性が保たれます

※2000年前半に書かれたものなので、REST APIよりもライブラリの関数をイメージしていると思われる。Goは標準ライブラリと呼ぶけれど、Javaは標準APIと呼ぶ。
https://docs.oracle.com/javase/jp/11/docs/api/

---

### 1.2.2 ABI

- ABIは特定のアーキテクチャにおけるソフトウェア間の低レベルなバイナリインタフェースを定義したものです
- ABIが保証するのはバイナリレベルの互換性（binary compatibility）です。ABIが同一ならば、リコンパイルせずともオブジェクトコードはどんなシステムでも動作することが保証されます。

Wikipediaより
ABIには、以下のような定義が含まれる。

- **CPU - 命令セット、エンディアンなど。**
- データ - データ型、大きさ、配置（アラインメント）など。
- 呼出規約 - 関数の引数がどのように渡され、リターン値がどのように渡されるかを定義したもの。
- システムコール - システムコール番号と具体的なシステムコールの仕組み。
- 実行ファイルやライブラリの詳細なフォーマット（UNIXならば、COFFやELFなど）。

---

### 1.2.2 ABI 命令セット

コンピュータアーキテクチャ（３）
https://www.mtl.t.u-tokyo.ac.jp/~sakai/hard/hard3.pdf

- 命令セット
  - コンピュータのすべての命令の集まり
- 命令セットアーキテクチャ
  - コンピュータで使われる命令の表現形式と各命令の動作を定めたもの
  - コンピュータに何ができるかをユーザに示し、どのようなハードウェア機構が必要であるかを設計者に教える

---

### 1.2.2 ABI 命令とは

命令 ＝ 操作 op ＋ 対象(オペランド/被演算子)

- オペランド
  - データレジスタ、メモリ語?、プログラムカウンタ、その他のレジスタ、即値

[![Image from Gyazo](https://i.gyazo.com/ee773191a3e9e94e23d941833a430341.png)](https://gyazo.com/ee773191a3e9e94e23d941833a430341)

e-Wordsより

**プログラムカウンタ**とは、マイクロプロセッサ（MPU/CPU）内部でデータを保持するレジスタの一種で、次に実行すべき命令が格納されているメモリ上の番地（アドレス）を保存しているもの。また、その保存しているアドレス値。「PC」と略記されることもある。

---

### 1.2.2 ABI エンディアン

http://www.ertl.jp/~takayuki/readings/info/no05.html

- 32ビットプロセッサなら、一度に32ビットの数値が取り扱います
- 32ビットは4バイトあるけど、どの順番でメモリに書けばいいの?
[![Image from Gyazo](https://i.gyazo.com/afd706c32b8712f30f4330098ec85670.gif)](https://gyazo.com/afd706c32b8712f30f4330098ec85670)

[![Image from Gyazo](https://i.gyazo.com/3163d7194991c2bd258a6fca3faa6bb7.png)](https://gyazo.com/3163d7194991c2bd258a6fca3faa6bb7)[![Image from Gyazo](https://i.gyazo.com/6bbc29aac6c4a36e0598da0828ce52c0.png)](https://gyazo.com/6bbc29aac6c4a36e0598da0828ce52c0)

---

### 1.2.2 ABI エンディアン と 命令セット

[![Image from Gyazo](https://i.gyazo.com/a859a93ac201d7dde5ea2648b75770cd.png)](https://gyazo.com/a859a93ac201d7dde5ea2648b75770cd)

---

## 1.3 標準仕様

- 技術的に言えば Linux はどの標準にも正式にはしたがっていません。
- Linux ではもっとも重要でかつ普及している 2 つの標準に準拠することを目標にしています。
  - POSIX （Portable Operating System Interface）
  - SUS（Single UNIX Specification）

### 1.3.1 POSIX と SUS の歴史

- POSIX（パーズィックスと読みます。国内ではポズィクス、ポジックスという読み方が多いようです。)

**本書でシステムコールや他のインタフェースがPOSIXで標準化されていると述べる場合は、SUS ではなく POSIX を指します。SUS が POSIX を包含しているためです。**

---

### 1.3.1 [補足] POSIX とは

e-Wordsより

- カーネルの機能を呼び出すシステムコールをC言語から利用するためのAPI仕様や標準ライブラリ関数などを定めており、POSIX仕様のみを用いて開発されたプログラムはPOSIX準拠のOSならばどれでも同じように動作させることができる。

- API以外にも、シェルのコマンド体系や、プロセスやスレッドの仕様、ファイルやディレクトリの構成、パスワードファイルなどのシステムデータベースの形式、アーカイブファイルの形式などについても標準を定めている。

---

### 1.3.2 C言語仕様

- 雑学

---

### 1.3.3 Linuxと標準仕様 (POSIX, SUS)

- 雑学

---

### 1.3.4 本書での標準仕様の扱い

- 本書ではLinuxカーネルの最新バージョン（2.6）、gcc Cコンパイラ（4.2）、Cライブラリ（2.5）を使用した、現代の Linux システムにおけるシステムプログラミングに集中します。

- ちなみに最近のUbuntu20.04だとKernel(5.10)、gcc(9.3) glibc(2.30)

---

## 1.4 Linuxプログラミングの概念

- 本節ではLinuxシステムのサービスの概要を簡潔にまとめます。

- 本書では読者がLinux環境にすでに慣れ親しんでいることを前提としています。

- シェルや基本的なコマンドを問題なく操作でき、C言語で記述された単純なソースファイルもコンパイルできるレベルです。

- 本書は Linux の概要やプログラミング環境について述べたものではなく、Linux システムプログラミングの基本的な「技」を解説したものです。

---

### 1.4.1 ファイルとファイルシステム

- ファイルは Linux の中でももっとも基本的かつ重要な概念です。Linux には **すべてのものはファイルである（everything-is-a-file）** という思想があります。


---

#### 1.4.1.1 通常ファイル

- 一般に「ファイル」と呼ぶものは、Linux では通常ファイル（レギュラファイル、regular file）と名付けています。ファイルはバイトがリニアに並んだデータ（バイトストリーム、バイト列、byte stream）を持っています。
  - **VMS** など他のオペレーティングシステムでは、レコード（record）などの高度に構造化されたファイルを備えているものもありますが、Linuxにはありません。

Wikipediaより
> OpenVMS (Open Virtual Memory System) は、DECによって設計された、タイムシェアリングシステム、バッチ処理およびトランザクション処理用のオペレーティングシステムである。当初は単にVMSと一般的には呼ばれており...

---

### 1.4.1.2 ディレクトリとリンク

- **ファイル名とinodeの組をリンク（link）と言います。**

---

### 1.4.1.3 ハードリンク

- リンクカウント初めて知った

---

### 1.4.1.4 シンボリックリンク

- ハードリンクは自身のinodeを参照先のinodeにする,シンボリックリンクは参照先ファイルパスを保存したファイル
  - シンボリックリンク自身のパス解決に加え、参照先ファイルのパス解決も必要になる

- ハードリンクは完全に透過で複数リンクも検知できるが、シンボリックだと誰が何を参照しているのか管理できない
  - ※ 透過性とは「ユーザが特に意識する必要があるか否かを表現する言葉で、内部ですべて自動的に処理される場合を透過性が高いと言います。」

---

### 1.4.1.5 スペシャルファイル

- キャラクタデバイス
- ブロックデバイス
- 名前付きパイプ(named pipe)
- Unixドメインソケット

- スペシャルファイルは、抽象化した概念をファイルシステム内にきれいに収める方法で、**「すべてのものはファイルである」**という思想に沿ったものです。

---

### 1.4.1.5 スペシャルファイル - キャラクタデバイス

- キャラクタデバイスはバイトがリニアに並んだものとしてアクセスし、デバイスドライバがキューにデータを1バイトずつ置き、ユーザ空間からキューに置かれたデータを読み取ります。
- キャラクタデバイスの典型的な例はキーボードです。
  - 例えば、ユーザが「peg」と入力した場合、アプリケーションはキーボードデバイスからp、e、gというデータが、この順序の通りに読み取れることを期待します。
  - データがなくなるとデバイスはEOF（ファイル終端、end-of-file）を返します。入力された文字を無視したり、異なる順序で読み取ることは意味がありません。キャラクタデバイスへはキャラクタデバイスファイル（character device file）を介してアクセスします。

---

### 1.4.1.5 スペシャルファイル - ブロックデバイス

- 対称的にブロックデバイスは、データをバイト配列としてアクセスするものです。
- ブロックデバイスは通常ストレージデバイスです。ハードディスク、フロッピーディスク、CD-ROM、フラッシュメモリなどはすべてブロックデバイスです。
- ブロックデバイスへはブロックデバイスファイル（block device file）を介し、アクセスします。

---

### 1.4.1.5 スペシャルファイル - 名前付きパイプ

- 名前付きパイプ（named pipe。「先入れ、先出し」、「first-in、first-out」を縮めて FIFO とも呼ばれます）はIPC（プロセス間通信、interprocess communication）の仕組みの1つで、スペシャルファイルのファイルディスクリプタを介した通信チャネルです。
- アプリケーションの出力を他のアプリケーションの入力へと「つなぐ」機能を持つ通常のパイプは、システムコールによりメモリ上に作成されるものでファイルシステム上に存在するものではありません。
- 名前付きパイプは通常のパイプと同様に扱えますが、FIFO スペシャルファイル（FIFO special file、または単にFIFO）というファイルを介してアクセスします。親子関係など特に関係を持たないプロセス同士でも、FIFO スペシャルファイルを介し通信可能です。

---

### 1.4.1.5 スペシャルファイル - ソケット

- 最後に挙げるスペシャルファイルはソケット（socket）です。
  - /var/run/mysqld/mysqld.sock
- ソケットはプロセス間の通信に使用します。
- 異なるマシン間でも通信可能です。
- インターネットを経由したソケット通信はホスト名とポート番号の組を用いて通信先を特定しますが、Unixドメインソケットではファイルシステム上に存在するスペシャルファイルを用いて特定します。
- Unixドメインソケットは単にソケットファイルとも呼ばれます。

---

### 1.4.1.5 ファイルシステムと名前空間

- 本を読む

- Unixでは名前空間が統合されている(Windowsだと`A:\plank.jpg`)
  - フロッピーなど外部メディア `/media/floppy/plank.jpg`(Windowsだと`A:\plank.jpg`)
  - 内部メディア `/home/captain/stuff/plank.jpg` (Windowsだと`C:\Users\captain\sutff\plank.jpg`)

- ファイルシステムとはファイルやディレクトリの集合体