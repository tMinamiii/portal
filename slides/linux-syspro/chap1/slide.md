---
marp: true
theme: gaia

---

# 1章 概要および主要概念

<style>
{
font-size: 22px;
}
</style>

- Linus Torvalds、LinuxとGit(Linuxを分散開発するために必要だった)を作った人

---

## 1.1 システムプログラミング

**X Window System**（エックスウィンドウシステム、別称：「X11」・「X」など）とは、ビットマップディスプレイ上でウィンドウシステムを提供する表示プロトコルである(Wikipediaより)

[![Image from Gyazo](https://i.gyazo.com/3d9a7cf27ef93d84c737e466e656c08e.png)](https://gyazo.com/3d9a7cf27ef93d84c737e466e656c08e)

---

### 1.1.1 システムコール

システムコールとは、ユーザー空間からOSに何らかの動作やリソースを要求するための、カーネル機能を呼び出す物

- read(): ファイルディスクリプターから読み込む
- write(): ファイルディスクリプター (file descriptor) に書き込む
- get_thread_area(): スレッド局所記憶領域を取り出す
- set_tid_Address(): thread IDのポインタを設定する ?

- スレッド局所記憶領域(thread local storage, TLS)
  - グローバル変数がプロセスごとに割り当てる変数
  - スレッドローカル変数はスレッドごとの領域に割り当てられており、その領域をスレッドローカルストレージという

---

#### 1.1.1.1 システムコールの発行 (アセンブリ言語 x86_64 Ubuntu20.04)

<style>
pre > code {
  font-size: 17px;
}
</style>

```assembly
.globl _start
_start:
    /* $の後が数字なら数字、文字なら変数。%はレジスタ */
    movl $4,%eax   /* write システムコール番号 */
    movl $1,%ebx   /* 書き込み先 - 標準出力 */
    movl $msg,%ecx /* 書き込むメッセージ */
    movl $13,%edx  /* メッセージの長さ */
    int $0x80      /* システムコール実行 割り込み実行 */

    movl $1,%eax /* システムコール終了番号 */
    movl $0,%ebx /* 終了状態 */
    int $0x80    /* システムコール終了 割り込み実行 */

.data
    msg: .asciz "Hello,World\n"
```

```sh
➜ ~ as -o main.o main.S
➜ ~ ld -o main.out main.o
➜ ~ ./main.out
hello,World
➜ ~
```

- [アセンブリコードで「int0x80」とはどういう意味ですか？](https://codehero.jp/assembly/1817577/what-does-int-0x80-mean-in-assembly-code)
- [さくっとアセンブリ入門 hello,world編](https://rabbitfoot141.hatenablog.com/entry/2016/05/01/124410)

---

#### 1.1.1.1 システムコールの発行 (C言語)

```c
#include<unistd.h>

int main(){
  const void *string = "Hello,World!\n";
  write(1, string, 13);
  return 0;
}
```

```sh
➜ ~ gcc write.c
➜ ~ ./a.out
Hello World!
➜ ~
```

---

### 1.1.2 Cライブラリ

- 本を読む

---

### 1.1.3 Cコンパイラ

- 本を読む

---

## 1.2 API と ABI

- API（application programming interface）
- ABI（application binary interface）です。
- API も ABI も異なる種類のソフトウェア間のインタフェースを定義するものです。

---

### 1.2.1 API

- APIとは、ソフトウェア間のソースレベルでのインタフェースを定義したもの
- 他のソフトウェアから呼び出し可能なインタフェース(通常は関数)の標準セットを定義し、抽象化したものです。
- 双方のソフトウェアがAPIにしたがっている場合に限り、動作は保証され、ソースレベルの互換性が保たれます

※ 2000年前半の書籍、REST APIではなくライブラリの関数をイメージしていると思われる。Goは標準ライブラリと呼ぶけれど、Javaは標準APIと呼ぶ。
https://docs.oracle.com/javase/jp/11/docs/api/

---

### 1.2.2 ABI

- ABIは特定のアーキテクチャにおけるソフトウェア間の低レベルなバイナリインタフェースを定義したものです
- ABIが保証するのはバイナリレベルの互換性（binary compatibility）です。ABIが同一ならば、リコンパイルせずともオブジェクトコードはどんなシステムでも動作することが保証されます。

Wikipediaより
ABIには、以下のような定義が含まれる。

- **CPU - 命令セット、エンディアンなど。**
- データ - データ型、大きさ、配置（アラインメント）など。
- 呼出規約 - 関数の引数がどのように渡され、リターン値がどのように渡されるかを定義したもの。
- システムコール - システムコール番号と具体的なシステムコールの仕組み。
- 実行ファイルやライブラリの詳細なフォーマット（UNIXならば、COFFやELFなど）。

---

### 1.2.2 ABI 命令セット

コンピュータアーキテクチャ（３）
https://www.mtl.t.u-tokyo.ac.jp/~sakai/hard/hard3.pdf

- 命令セット
  - コンピュータのすべての命令の集まり
- 命令セットアーキテクチャ
  - コンピュータで使われる命令の表現形式と各命令の動作を定めたもの
  - コンピュータに何ができるかをユーザに示し、どのようなハードウェア機構が必要であるかを設計者に教える

---

### 1.2.2 ABI 命令とは

命令 ＝ 操作 op ＋ 対象(オペランド/被演算子)

- オペランド
  - データレジスタ、メモリ語?、プログラムカウンタ、その他のレジスタ、即値

[![Image from Gyazo](https://i.gyazo.com/ee773191a3e9e94e23d941833a430341.png)](https://gyazo.com/ee773191a3e9e94e23d941833a430341)

e-Wordsより

**プログラムカウンタ**とは、マイクロプロセッサ（MPU/CPU）内部でデータを保持するレジスタの一種で、次に実行すべき命令が格納されているメモリ上の番地（アドレス）を保存しているもの。また、その保存しているアドレス値。「PC」と略記されることもある。

---

### 1.2.2 ABI エンディアン

http://www.ertl.jp/~takayuki/readings/info/no05.html

- 32ビットプロセッサなら、一度に32ビットの数値が取り扱います
- 32ビットは4バイトあるけど、どの順番でメモリに書けばいいの?
[![Image from Gyazo](https://i.gyazo.com/afd706c32b8712f30f4330098ec85670.gif)](https://gyazo.com/afd706c32b8712f30f4330098ec85670)

[![Image from Gyazo](https://i.gyazo.com/3163d7194991c2bd258a6fca3faa6bb7.png)](https://gyazo.com/3163d7194991c2bd258a6fca3faa6bb7)[![Image from Gyazo](https://i.gyazo.com/6bbc29aac6c4a36e0598da0828ce52c0.png)](https://gyazo.com/6bbc29aac6c4a36e0598da0828ce52c0)

---

### 1.2.2 ABI エンディアン と 命令セット

[![Image from Gyazo](https://i.gyazo.com/a859a93ac201d7dde5ea2648b75770cd.png)](https://gyazo.com/a859a93ac201d7dde5ea2648b75770cd)

### 1.2.2 ABI 参考資料

API/ABI changes review for glibc
https://abi-laboratory.pro/?view=timeline&l=glibc

---

### 1.3 標準仕様

- 標準は複数存在しますが、技術的に言えば Linux はどの標準にも正式にはしたがっていません。
- Linuxではもっとも重要でかつ普及している 2 つの標準に準拠することを目標にしています。
  - POSIX（Portable Operating System Interface）と
  - SUS（Single UNIX Specification）です。

### 1.3.1 POSIXとSUSの歴史

- 1980 年代中頃に、現在の Free Software の創始者とも呼ばれる Richard Stallman が、標準の名前として POSIXを提案
- 1980 年代後半から 1990 年代初頭にかけ、Unix システムのベンダ達は「Unix Wars」状態に .... いろいろあった

- **本書でシステムコールや他のインタフェースがPOSIXで標準化されていると述べる場合は、SUS ではなく POSIX を指します。SUS が POSIX を包含しているためです。**

---

#### 1.3.1 (補足) POSIX とは

e-Wordsより

- カーネルの機能を呼び出すシステムコールをC言語から利用するためのAPI仕様や標準ライブラリ関数などを定めており、POSIX仕様のみを用いて開発されたプログラムはPOSIX準拠のOSならばどれでも同じように動作させることができる。
- API以外にも、シェルのコマンド体系や、プロセスやスレッドの仕様、ファイルやディレクトリの構成、パスワードファイルなどのシステムデータベースの形式、アーカイブファイルの形式などについても標準を定めている。

---

### 1.3.2 C言語仕様 (雑学)

- Dennis Ritchie と Brian Kernighan の著名な『The C Programming Language』（Prentice Hall 刊、邦題『プログラミング言語 C』共立出版刊）は、1978年の出版以来、非公式ながらも C言語の標準仕様と位置付けら
れていました。
- 1995 年には ISO は C 言語を改版し、ISO C95（あまり普及していません）を、さらに 1999 年には大幅な更新を加えたISO C99を公開しました。

---

### 1.3.3 Linuxと標準仕様

- Linux では POSIX および SUS に準拠することを念頭に置いています。
- さらに重要な点は、Linux が POSIX と SUS が要求する通りの動作を実装しようと努めていることで、標準に準拠していない動作は全般的にバグと見做されます
- Linuxシステムの多くの部分を標準化したLSB（Linux Standard Base）はさまざまなLinuxディストリビューションで採用されています。
- LSBは、POSIXとSUSを拡張し独自の標準を追加したものです。
- LSB準拠のシステムならばオブジェクトコードを変更せずとも動作可能なように、バイナリレベルの標準化も目標としています。

---

### 1.3.4 本書での標準仕様の扱い

- 本書では特定の標準に肩入れしないように注意を払って記述しています。
- 本書ではLinuxカーネルの最新バージョン（2.6）、gcc Cコンパイラ（4.2）、Cライブラリ（2.5）を使用した、現代の Linux システムにおけるシステムプログラミングに集中します。
  - 私のUbuntu20.04は、Kernel(5.10)、gcc(9.3) glibc(2.30)

---

### 1.4 Linux プログラミングの概念

- 本節ではLinuxシステムのサービスの概要を簡潔にまとめます。
- Linuxを含むすべてのUnixシステムは共通の概念とインタフェースを備えており、これこそが実際の Unix の定義とも言えます。
- ファイルやプロセスの概念、パイプやソケットの操作インタフェースなどは、Unix とは何かを示す中核にあります。

---

### 1.4.1 ファイルとファイルシステム - ファイルディスクリプタとは？

- ファイルは Linux の中でももっとも基本的かつ重要な概念です。Linux には **すべてのものはファイルである（everything-is-a-file）という思想があります**
- ファイルにアクセスするにはまずオープンする必要があります。
- オープンしたファイルを使用する際にはディスクリプタを使用します。
  - ディスクリプタは一意な識別子で、オープンしたファイルのメタデータとファイルを対応させるものです。
  - Linux カーネル内部では、ディスクリプタは整数（C 言語の int 型）で表現され、ファイルディスクリプタ（ファイル記述子、file descriptor）または省略してfdと呼ばれます。
  - ファイルディスクリプタはユーザ空間と共有され、アプリケーションがファイルへアクセスする際に使用されます。
  - Linuxシステムプログラミングの多くの部分は、ファイルディスクリプタを使用したファイル操作やオープン / クローズです。

---

### 1.4.1 ファイルとファイルシステム - ファイルディスクリプタとは？(補足)

>プログラムが特定のファイルを指定して「開く」操作を行うと、カーネル内のファイルテーブルと呼ばれる領域に対応する項目が作成され、対象ファイルのストレージ上での位置（パス）、ファイル内の現在の操作位置などの情報が記録される。

>このテーブル内での当該ファイルの識別番号がファイルディスクリプタで、以降はプログラムからファイルディスクリプタを指定して、どのファイルへの操作なのかをカーネルに伝達する。

>通常、ファイルディスクリプタは0から順番に未使用の最も小さい値が与えられるようになっており、プログラム上では整数型の変数などとして扱われる。ただし、番号によっては固定的に特殊な対象を表す場合があり、一般的には「0」は標準入力（stdin）、「1」は標準出力（stdout）、「2」は標準エラー出力（stderr）としてプログラムの実行中は常に開いた状態になっている。

IT用語辞典 e-Wordsより

---

#### 1.4.1.1 通常ファイル

- 「通常ファイル」はその内容としてバイトがリニアに並んだデータ（バイトストリーム、バイト列、 byte stream）を持っています
- システムレベルで考えると、Linuxがファイルに対しバイトストリーム以外の構造を使用することはありません。
- ファイルのサイズはバイト単位で表現し、ファイルサイズ（レングス、length）と呼びます。
- トランケート操作を行うと、ファイルサイズを変更できます。
  - 元のサイズよりも小さなサイズにする場合は末尾が削られる
  - 元のサイズよりも小さなサイズにする場合は0フィルされる
- カーネルは同時に行われるファイルアクセスに対しなんら制限を加えません
  - アプリケーションで管理する
- ファイルへアクセスする際にはファイル名を使用するのが常ですが、 ファイルに実際に対応し、参照の際に使用されるのはinode番号です(statコマンドでinodeがわかる)

[![Image from Gyazo](https://i.gyazo.com/8bb94356f1543cbf7b1ce9aaddebba0a.png)](https://gyazo.com/8bb94356f1543cbf7b1ce9aaddebba0a)

---

#### 1.4.1.2 ディレクトリとリンク

- ユーザ空間からのファイルオープンは、inode番号ではなく、常にファイル名を使用します。
- ファイル名と inode の組をリンク（link）と言います。
- **カーネルは対象ファイル名を持つ親ディレクトリをオープンし、指定されたファイル名を検索します。さらにファイル名からinode番号を、inode 番号から inode を特定します**
- 絶対パス`/home/blackbeard/landscaping.txt` というファイルパスがあった場合
  - カーネルは / から検索を始め、home に対応する inode を特定します。次に blackbeard の inode を、最後にlandscaping.txtのinodeを得ます。この処理をディレクトリ解決またはパス解決という
  - Linux カーネルでは dentry cache †というキャッシュも使用しており、パス解決の結果をメモリ上に蓄えるようにしています。
- 相対パスが与えられた場合は、カレントディレクトリからパス解決処理を行います。

---

#### 1.4.1.3 ハードリンク

- 同じinodeに対しファイル名が異なる複数の組が存在する状態をハードリンク（hard link）と呼びます
- すべてのリンクが削除されるまでデータを破棄しないために、inodeにはリンクカウント（link count）というデータが存在します。
- ファイルを削除すると、リンクカウントは 1 減らされます。リンクカウントが 0 になった場合のみ、inode や対応するデータがファイルシステムから破棄されます。

---

#### 1.4.1.3 シンボリックリンク

- ハードリンクは異なるファイルシステムにまたがることはできません。
  - inode 番号はその inode が存在するファイルシステム外では意味を持たなくなるためです。
- 代わりにUnixシステムではシンボリックリンク（symbolic link）も備えています
- シンボリックリンクは自身のinodeとデータを持ち、シンボリックリンク先のパス名を保持します
  - シンボリックリンクの場合はパス解決が２回行われるのでハードリンクに比べてオーバーヘッドが増えます
- ハードリンクは完全に**透過**で、複数リンクされていることも検知できます。シンボリックリンクの操作は専用のシステムコールを必要としますが、この非透過性もハードリンクよりも高度なショートカットとして機能するため、許容する向きもあります。
  - ユーザが特に意識する必要があるか否かを表現する言葉で、内部ですべて自動的に処理される場合を透過性が高いと言います。

---

#### 1.4.1.5 スペシャルデバイス

Linuxでは4種類のスペシャルファイルに対応しています。

  - ブロックデバイス、
  - キャラクタデバイス、
  - 名前付きパイプ（named pipe）、
  - Unixドメインソケットです。

スペシャルファイルは、抽象化した概念をファイルシステム内にきれいに収める方法で、「すべてのものはファイルである」という思想に沿ったものです。

---

#### 1.4.1.5 スペシャルデバイス - キャラクタデバイス・ブロックデバイス

- キャラクタデバイス（character device）とブロックデバイス（block device）です。デバイスそれぞれに専用のデバイスファイルが存在します。
- キャラクタデバイスの例はキーボードです。
- ブロックデバイスは、データをバイト配列としてアクセスするものです。ブロックデバイスは通常ストレージデバイスです。ハードディスク、フロッピーディスク、CD-ROM、フラッシュメモリなどはすべてブロックデバイスです。
- ブロックデバイスへはブロックデバイスファイル（block device file）を介し、アクセスします

[![Image from Gyazo](https://i.gyazo.com/c420bec28483b7f85f7938704ef1cd2b.png)](https://gyazo.com/c420bec28483b7f85f7938704ef1cd2b)

第1列の「c」で始まるものがキャラクタ・デバイス，「b」で始まるものがブロック・デバイスです。

---

#### 1.4.1.5 スペシャルデバイス - 名前付きパイプ

> 通常のシェルで使用する無名のパイプとは異なり、名前付きパイプはファイルシステムを使用する。mkfifo()[1] または mknod()[2] で明示的に作成し、2つのプロセスが名前を指定してそのパイプにアクセスでき、一方のプロセスは読み手としてオープンし、もう一方は書き手としてオープンする。名前付きパイプを作成する mkfifo というコマンドもある。

> 例えば、名前付きパイプを作成し、そのパイプに入力されたものを gzip で圧縮する場合、次のようにすればよい。

```sh
mkfifo my_pipe
gzip -9 -c < my_pipe > out.gz &
```

https://ja.wikipedia.org/wiki/%E5%90%8D%E5%89%8D%E4%BB%98%E3%81%8D%E3%83%91%E3%82%A4%E3%83%97

---

#### 1.4.1.5 スペシャルデバイス - ソケット

`/var/lib/mysql/mysql.sock`

- ローカルのmysql-serverにmysql-clientで接続するときに使用するソケットファイル
- ソケットファイルを通してSQLを実行する
- mysqlの接続方法はtcp or socket (socketのほうが速いがローカルからしかアクセスできない)

---


#### 1.4.1.6 ファイルシステムと名前空間 1

- Windowsの名前空間 `C:\` とか `A:\`
- Unix/Linuxでは名前空間は統合されています
  - フロッピー上のファイルなら /media/floppy/plank.jpg
  - HDD/SSD上などなら /home/captain/stuff/plank.jpg ででもアクセスできます。
- ファイルシステム（filesystem）とは、ファイルやディレクトリの集合体で、ある形式にしたがい階層を構成するものです
  - グローバルなファイル/ディレクトリの名前空間へ、個別にファイルシステムを追加/削除可能です
  - この操作をマウント（mount）、アンマウント（unmount）と、それぞれ言います。
  - 例えば、CD-ROM を /media/cdrom へマウントし、CD-ROM 内のファイルへアクセスする場合は、マウントポイントである/media/cdrom以下へアクセスします。

- Linuxではメモリ上にのみ存在する仮想ファイルシステムや、ネットワーク越しのマシン上に存在するネットワークファイルシステムも使用可能です

---

#### 1.4.1.6 ファイルシステムと名前空間 2

- ブロックデバイスへのアクセスはセクタ（sector）という単位で行われます。
  - 512 バイトが多く使用されます。
  - ブロックデバイスへはセクタよりも小さいサイズの単位ではアクセスできません。
  - すべての I/O は 1 つまたは複数のセクタ単位で行われます。
- ファイルシステムへのアクセスはブロック（block）という単位で行われます。
  - ブロックはファイルシステムの概念であり、ファイルシステムが存在する物理メディアの概念ではありません。
  - ブロックのサイズは通常はセクタサイズの2の累乗になり、一般的にはセクタサイズよりも大きくなります。

---

#### 1.4.1.6 ファイルシステムと名前空間 3

- 元来 Unix システムは名前空間を 1 つしか持たず、システム内のすべてのユーザ、プロセスで共有し、同じ名前空間を参照していました。**Linuxではプロセスごとの名前空間**という革新的な方式を採用しており、プロセスそれぞれに固有のファイル/ディレクトリ階層を持てるようになっています。
  - わからない

- プロセスは、親プロセスの名前空間をデフォルトで受け継ぎますが、自身用のマウントポイントやルートディレクトリを持つ名前空間の作成も可能です。

---

#### 1.4.2 プロセス

- Unixシステムでもっとも基本的かつ重要な概念をファイルとしたら、次に重要なものはプロセスです。
- プロセスとは実行状態にあるオブジェクトコード データ、リソース、状態、仮想コンピュータなども含みます。
  - 仮想コンピューターはFreeBSD jail ?

- プロセスは実行可能オブジェクトコードから生成されます。
  - カーネルが解釈可能な実行形式ファイルに収められた、マシンが実行可能なオブジェクトコード

---

#### 1.4.2 プロセス - 実行形式ファイルとセクション

- 実行形式ファイルにはメタデータおよびセクションが収められている
- セクションとはオブジェクトコードをリニアに保存したものでメモリにもリニアにロードされるもの
  - テキストセクション(コードセクション): プログラムのコードが格納
  - データセクション: データが格納されています
  - bss セクション: 初期値を持たないデータ領域を意味します
    - block started by symbol または block storage segment の頭文字を取ったもの

[![Image from Gyazo](https://i.gyazo.com/dd9d3088642f84504e19d7948f82c9f9.gif)](https://gyazo.com/dd9d3088642f84504e19d7948f82c9f9)


- アブソリュートセクション, undefinedセクションもある（わからん）

---

#### 1.4.2 プロセス - 仮想メモリと仮想プロセッサ

- Linuxカーネルはプリエンプティブなマルチタスクと仮想メモリ機能を備えており、各プロセスには仮想的なプロセッサおよび仮想的なメモリ空間が与えられます。

- プロセス側からは自身がシステム全体を独占しているように見えます。
  - 実際はカーネルは途切れることがないように、また透過的にプリエンプトし、プロセスを再スケジューリングし、システムのプロセッサを実行中のすべてのプロセス間で共有します。
- 同様にプロセスにはそれぞれのリニアアドレス空間が与えられ、システムのメモリすべてを自分が独占しているかのように見えます。
  - 実際は、仮想メモリとページング機能を使用し、カーネルが複数のプロセスをシステム上に共存させており、それぞれのプロセスは異なるアドレス空間で動作します。

なんとなく理解

---

#### 1.4.2.1 スレッド

- プロセスには1つまたは複数のスレッドがあります。
  - 大半のプロセスはスレッドを1つもつ(シングルスレッド(single-threaded))
  - 複数のスレッドを持つプロセスはマルチスレッド(multithreaded)です
- **スレッドとはプロセス内の実行単位で、処理実行を担当する抽象概念です。**
  - 従来の Unix アプリケーションはシングルスレッドです。
  - 高速なプロセス作成や信頼性の高い IPC などの影響もあり、マルチスレッドが必要不可欠となる場面は多くありません。

- スレッドは専用のスタック(stack。ローカル変数の格納場所)、プロセッサ状態、オブジェクトコードの現在位置(通常はプロセッサの命令ポインタ(instruction pointer)が保持する)を持ちます。
- プロセスの他の部分のほとんどはすべてのスレッドで共有されます。(???)
- Linuxカーネル内部ではスレッドは独立したものとして実装されています。
  - 通常のプロセスと同等ですが、リソースの一部(もっとも重要なアドレス空間)を共有しています。
    - スレッド間、プロセスと共有しているの意？？

---

#### 1.4.2.2 プロセスの階層

- 各プロセスにはプロセス ID(process ID、pid)という一意な正の整数が割り振られます。
- 最初のプロセス の pid は 1 で、以降のプロセスには連続した一意の pid が与えられます。
- Linuxではプロセスは厳密な階層を構成します。これをプロセスツリー(process tree)と言います。

- プロセスツリーの最上位には最初のプロセス init があります。通常は init(8)というコマンドです。

- 元のプロセスを親プロセス(parent)、新規に作成したプロセスを子プロセス(child)とそれぞれ呼びます。
  - 最初のプロセス(init)を除くすべてのプロセスには親プロセスが存在します。
  - **子プロセスよりも先に親プロセスが終了した場合は、カーネルが子プロセスを init プロセスへつなぎ直します(reparent)。**

- プロセスは終了してもすぐにはシステムから削除されません。カーネルはプロセスの一部をメモリ内に残しておき、親プロセスが子プロセスの終了状態を確認できるようにします。これをプロセスの終了待ち(waiting on)と言います。
  - 親プロセスの子プロセス終了待ち合わせが完了すると、子プロセスは完全に破棄されます。
  - 終了はしてもまだ終了待ち合わせが行われてないプロセスをゾンビプロセス(zombie)と呼びます。
  - つなぎ直されたプロセスが永久にゾンビになってしまわないようにinitプロセスは定期的にすべての子プロセスの終了を待ち合わせます。

---



#### 1.4.3 ユーザーとグループ 1

- Linuxでの認証はユーザ(user)とグループ(group)という単位で管理されます。
- ユーザにはそれぞれユーザID(uid)という一意な正の整数が割り振られます。
- プロセスにも、実行したユーザを識別できるように、このuidが対応付けられ、これをプロセスの実uid(real uid)と言います。

- ログイン処理
  - ログイン処理ではユーザはユーザ名とパスワードをlogin(1)コマンドへ入力します。
  - 正当なユーザ名と正 しいパスワードが入力されると、login(1)コマンドは、/etc/passwdで指定されたユーザのログインシェル(login shell)を起動し、シェルプロセスの uid をユーザの uid へ変更します。
  - 子プロセスは親プロセスから uid を受け継ぎます。
  - uid 0 は root という特殊なユーザを表します。root ユーザは特権を持ち、システム上でほぼすべてのことを行えます。
  - 例えばプロセスの uid を変更できるのは root ユーザだけです。このため、login(1)コマン ドは root ユーザの権限で実行されます。

---

#### 1.4.3 ユーザーとグループ 2


- プロセスは、実uid 以外にも 実効uid(effective uid)、saved uid、filesystem uid を持ちます。
  - 実uid が常 にプロセスを起動したユーザを表す
  - 実効uidは他のユーザ権限でプロセスを実行可能にするルールの範囲内で、変化する場合があります。
  - saved uid は元の実効 uid を保存するもので、ユーザが実効 uid を 変更する前の uid を必要とする際に使用します。
  - filesystem uid は、通常は実効 uid と同一ですが、ファイル システムへアクセスする際の権限確認に使用されます。

- ユーザは1つまたは複数のグループに属します。(Linuxでdockerを使うときはdockerグループに所属させる)
  - /etc/passwdに記述したグループをプライマリグループ またはログイングループ(primary or login group)と呼びます。
  - その他にも補助的に複数のグループに参加可 能で、こちらは/etc/groupへ記述します。
  - このためプロセスにも対応するグループID(group ID、gid)が存在し、uid 同様に実gid(real gid)、実効gid(effective gid)、saved gid、filesystem gid があります。

- プロセスは通常ユーザのログイングループと関連付けられます。 プロセスが何らかの操作を行う際には、ある特定の条件に合致した場合にのみ、その操作を許可するセキュリティチェックが行われます。

---

#### 1.4.4 パーミッション

- パーミションビットは、オーナ、グループ、その他のユーザのそれぞれに対し、ファイルへの読み取り、書き込み、実行の権限を表します。
- オーナ、グループ、その他のユーザのクラスごとに 3 ビットを用い、全体では 9 ビッ トになります。
- ファイルのオーナとパーミションは inode へ保存されます。

- 通常ファイル
  - 読み取り用にオープンできるか
  - 書き込み用にオープンできるか、
  - 実行できるか
- スペシャルファイル
  - 読み書きの権限は通常ファイルと同様ですが、実際に可能かどうかはスペシャルファイルに依存します。
  - 実行権限はスペシャルファイルの場合には無視されます。
- ディレクトリ
  - 読み取り権限が与えられていればディレクトリ下のファイル一覧を得られ
  - 書き込み権限の場合はディレクトリ下に新たなリンクを作成でき
  - 実行権限の場合はパス解決処理でディレクトリを参照できるようになります

---

#### 1.4.5 シグナル

**シグナル(signal)とは非同期片方向の通信方法です。**

- アクセス違反(segmentation fault)やユーザが割り込みキー(Ctrl-C)を入力したなど、何らかの**イベントをプロセスへ通知するために使用します。**
- プロセスはシグナルを受け取った際の動作をカスタマイズできます。
  - 例外があり、下のxの2つのシグナルの動作は変更できません。
    - SIGKILLは常にプロセスを終了
    - SIGSTOPは常にプロセスを停止（実行の中断）

- デフォルトの動作は、シグナルの種類により異なります。
  - 単にプロセスを終了 / コアダンプし終了 / 実行を中断 / 何もしない
- プロセスはデフォルトの動作をそのまま使用することも、独自のシグナル処理を明示的に追加したり、または無視することも可能です。
  - 独自のシグナル処理を加えた場合は、ユーザ定義のシグナルハンドラ（signal handler）関数が実行されます
- プロセスはシグナルを受け取ると、即座にシグナルハンドラ関数へ制御を渡し、シグナルハンドラ関数が処理を終えると、割り込まれた元の位置へ制御を戻します。

---

#### 1.4.6 プロセス間通信

- プロセスが互いに情報をやり取りし、イベントを通知できるようにする仕組み
- Linuxカーネルでは、従来からあるUnixのIPCだけではなく、独自の仕組みも追加しています。
- LinuxのIPC
  - **パイプ（pipe）**: 「|」
  - **名前付きパイプ（named pipe）**: mkfifo
  - **セマフォ（semaphore）**: 複数プロセス間で排他制御する仕組み？？
  - **メッセージキュー（message queue）**: プロセス間の情報交換の方法
  - **共有メモリ（shared memory）** 2つ以上のプロセスでのメモリを共有
  - **futex（Fast Userspace muTex）**:
    - 指定したアドレスの値が変更されるのをプログラムが待つ手段を提供
    - 特定のアドレスに対して待機中のプロセスを wake (起床) させる手段を提供

---

#### 1.4.7 ヘッダファイル

- システムプログラミングで使用するヘッダファイルはカーネル
- またはglibcに含まれるもので、C言語の標準機能である<string.h>
- Unix が通常備えている <unistd.h>

---

#### 1.4.8 エラー処理

- 関数はコール元に対し、戻り値を用いてエラーを通知します。
- **-1**が一般的に使用されますが、関数により値は異なります。
- 戻り値は何らかのエラーが発生したことを示すだけで、その原因についての情報は持ちません。
- エラーの原因はグローバル変数 errno が表します。errno は、<errno.h> で定義されています。
- errnoは直接に参照、変更可能です。

```c
extern int errno;
```

erronoの値とメッセージはは定数マクロに定義されている(表1-2)

---

#### 1.4.8 エラー処理 perror()

- errnoの値を適切なメッセージへ変換するライブラリ関数はいくつかあります。

- perror()は、errno の現在の値に対応したエラーメッセージを標準エラー出力へ出力します。
- パラメータのstrが与えられれば、エラーメッセージの直前に、コロンを付加し、同時に出力します。

```c
#include <stdio.h>
void perror (const char *str);
```

```c
if (close (fd) == -1)
  perror ("close");
```

---

#### 1.4.8 エラー処理 strerror()および strerror_r() 1

strerror()および strerror_r()という C ライブラリ関数もあります。

```c
#include <string.h>
char * strerror (int errnum);
int strerror_r (int errnum, char *buf, size_t len);
```

- strerror()はerrnumに与えられたエラーに対応するエラーメッセージ（文字列）へのポインタを返します。
  - アプリケーションからは文字列を変更することはできません。
  - また再度 perror()や strerror()をコールすると、文字列は上書きされます。

- strerror_r()はスレッドセーフです。lenのサイズを持つバッファをあらかじめ確保し、bufへ与え、コールすると、バッファへエラーメッセージがコピーされます。strerror_r()は処理に成功すると0を、エラー発生時には -1 を、それぞれ返します

---

### 1.4.8 エラー処理 strerror()および strerror_r() 2

- 少数ですが、戻り値がどんな値にもなりうる関数もあります。
- この場合には、コール前にerrnoへ0を代入しておき、コール後に0か否かを確認する必要があります。この種の関数は、エラー発生時にerrnoへ設定する値が0 以外であることが保証されています。サンプルコードを挙げます。

```c
errno = 0;
arg = strtoul(buf, NULL, 0); // 文字列をunsigned long値に変換
if (errno)
  perror("strtoul");
```

---

#### 1.4.8 エラー処理 strerror()および strerror_r() 3

errnoの確認処理でよくある誤りは、どんなライブラリ関数、システムコールでもerrnoを上書きし得るという点を忘れてしまうことです
(fprintfの処理のどこかでエラーになっても変わってしまうことがある)

```c
if (fsync(fd) == -1) { // fsyncしてエラー
  fprintf(stderr, "fsync failed!\n");
  if (errno == EIO) // fprintfしている間にerrnoが変わっている可能性がある
    fprintf(stderr, "I/O error on %d!\n, fd)
}
```

---

#### 1.4.8 エラー処理 strerror()および strerror_r() 4

関数コールに跨りerrnoを使用する場合は、一度退避する必要があります。

```c
if (fsync (fd) == -1) {
  int err = errno; // システムコールを呼び出す前にローカル変数に退避
  fprintf (stderr, "fsync failed: %s\n", strerror (errno));  // fprintf処理中にerrno変わる可能性あり
  if (err == EIO) { //退避しているのでOK
    /* I/O関連のエラーの場合は処理中止 */
    fprintf (stderr, "I/O error on %d!\n", fd);
    exit (EXIT_FAILURE);
  }
}
```

- シングルスレッドのアプリケーションでは、本節で述べたように、errnoは単純なグローバル変数ですが、**マルチスレッドの場合は errno はスレッドごとに用意されており、スレッドセーフになっています。**

---

#### 1.5　システムプログラミングへ出発

　本章ではLinuxのシステムプログラミングの基礎を解説し、プログラマから見たLinuxシステムの概要を述べました。次章ではファイル入出力の基本を解説します。ファイルの読み書きは当然解説しますが、Linuxではファイルとして多数のインタフェースを備えているため、本格的なファイル入出力は単なるファイル操作よりもずっと複雑になります。システムプログラミングへ向かう基礎段階という最初の旅も終わり、いよいよ実際のシステムプログラミングの次の一歩を踏み出す時です。行きましょう。
