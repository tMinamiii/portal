---
marp: true
theme: gaia

---

# 1章 概要および主要概念

<style>
{
font-size: 22px;
}
</style>

- 本書はシステムプログラミング（system programming）、すなわちシステムソフトウェア（system software） 開発の真髄を解説するものです
- GUI アプリケーションなど他のソフトウェアはほとんどがより上位に位置し、下位のソフトウェア、ハードウェアへアクセスすることは極めてまれか、もしくは全くありません
- 上位(GUI)のシステム概念の単なる土台になるのがシステムプログラミングです
- システムプログラミングに対する理解はすべてのプログラマに必須と言えます

- Linus Torvalds、Linuxを作った人(gitも)
[![Image from Gyazo](https://i.gyazo.com/81a46bb3d011bc133514477914987640.jpg)](https://gyazo.com/81a46bb3d011bc133514477914987640)

---

## 1.1 システムプログラミング

本書はこの疑問および以下のような疑問に答えるためのものです。

- Linux でシステムレベルのアプリケーションを開発するにはどうすれば良いか。
- カーネルや C ライブラリが提供するものは具体的に何か。
- 効率的なソースコードを記述するには、また Linux ではどんな仕掛けが用意されているか。
- 他のUnixシステムと比べて、Linuxではどんな巧妙なシステムコールが用意されているか。また、どんな動作をするのか。

Linux のシステムプログラミングでは重要なものが 3 つあります。
- システムコール
- C ライブラリ
- C コンパイラです。
まずそれぞれについて概要をまとめます。

---

### 1.1.1 システムコール

システムコールとは、ユーザー空間からOSに何らかの動作やリソースを要求するための、カーネル機能を呼び出す物

- read(): ファイルディスクリプターから読み込む
- write(): ファイルディスクリプター (file descriptor) に書き込む
- get_thread_area(): スレッド局所記憶領域を取り出す
- set_tid_Address(): thread IDのポインタを設定する ?

---

### ファイルディスクリプタとは？

> ファイル（への通り道）に割り振られる番号で、ファイルを識別するための目印

 ([「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word14383.html)) より


>プログラムが特定のファイルを指定して「開く」操作を行うと、カーネル内のファイルテーブルと呼ばれる領域に対応する項目が作成され、対象ファイルのストレージ上での位置（パス）、ファイル内の現在の操作位置などの情報が記録される。

>このテーブル内での当該ファイルの識別番号がファイルディスクリプタで、以降はプログラムからファイルディスクリプタを指定して、どのファイルへの操作なのかをカーネルに伝達する。

>通常、ファイルディスクリプタは0から順番に未使用の最も小さい値が与えられるようになっており、プログラム上では整数型の変数などとして扱われる。ただし、番号によっては固定的に特殊な対象を表す場合があり、一般的には「0」は標準入力（stdin）、「1」は標準出力（stdout）、「2」は標準エラー出力（stderr）としてプログラムの実行中は常に開いた状態になっている。

([IT用語辞典 e-Words](https://e-words.jp/w/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF.html))

---

### スレッド局所記憶領域(thread local storage, TLS)

- グローバル変数がプロセスごとに割り当てる変数
- スレッドローカル変数はスレッドごとの領域に割り当てられています。その領域をスレッドローカルストレージという
    - errno: errnoは、マルチスレッドという概念が導入される前のもの。スレッドローカルにしないと各スレッドでのシステムコール呼び出しの結果で errno が上書きされるという事故に繋がります

---

#### 1.1.1.1 システムコールの発行(コール)  1/3

- ユーザーアプリケーションが直接的にカーネル内のコードを実行したり、データを操作することは禁止されている

- カーネル定義した方法にしたがって、アプリケーションからカーネルへ入り(trap)許可された範囲でカーネルコードを実行
    - /kernel/traps.c: 割込みハンドラとしてシステムコールが登録されている

- i386(32bit)システムでは、ユーザーアプリケーションがソフトウェア割り込み命令**int**(interrupt ?) を実行します。割り込み番号は 0x80 (`int 0x80`という命令が実行される)。

- 割り込み番号は `0x80`(int 0x80。この割り込み命令によりカーネル空間、すなわち**ソフトウェア割り込みハンドラを実行するカーネル内の保護された空間**へと切り替わりる。

---

#### 1.1.1.1 システムコールの発行(コール)  2/3 (アセンブリ言語 Ubuntu20.04)

<style>
pre > code {
  font-size: 17px;
}
</style>

```assembly
.globl _start
_start:
    /* $の後が数字なら数字、文字なら変数。%はレジスタ */
    movl $4,%eax   /* write システムコール番号 */
    movl $1,%ebx   /* 書き込み先 - 標準出力 */
    movl $msg,%ecx /* 書き込むメッセージ */
    movl $13,%edx  /* メッセージの長さ */
    int $0x80      /* システムコール実行 割り込み実行 */

    movl $1,%eax /* システムコール終了番号 */
    movl $0,%ebx /* 終了状態 */
    int $0x80    /* システムコール終了 割り込み実行 */

.data
    msg: .asciz "Hello,World\n"
```

```sh
➜ ~ as -o main.o main.S
➜ ~ ld -o main.out main.o
➜ ~ ./main.out
hello,World
➜ ~
```

- [アセンブリコードで「int0x80」とはどういう意味ですか？](https://codehero.jp/assembly/1817577/what-does-int-0x80-mean-in-assembly-code)
- [さくっとアセンブリ入門 hello,world編](https://rabbitfoot141.hatenablog.com/entry/2016/05/01/124410)

---

#### 1.1.1.1 システムコールの発行(コール)  3/3 (C言語)

```c
#include<unistd.h>

int main(){
  const void *string = "Hello,World!\n";
  write(1, string, 13);
  return 0;
}
```

```sh
➜ ~ gcc write.c
➜ ~ ./a.out
Hello World!
➜ ~
```

---

#### (おまけ) 1.1.1.1 システムコールの発行(コール)  3/3

```assembly
int main(){
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
  const void *string = "Hello Write!\n";
   c:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 13 <main+0x13>
  13:   48 89 45 f8             mov    %rax,-0x8(%rbp)
  write(1, string, 13);
  17:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  1b:   ba 0d 00 00 00          mov    $0xd,%edx
  20:   48 89 c6                mov    %rax,%rsi
  23:   bf 01 00 00 00          mov    $0x1,%edi
  28:   e8 00 00 00 00          callq  2d <main+0x2d>
  return 0;
  2d:   b8 00 00 00 00          mov    $0x0,%eax
}
  32:   c9                      leaveq
  33:   c3                      retq
```

---

#### 1.1.1.1 システムコールの発行(コール)  3/3

- アプリケーションはカーネルに対し、実行するシステムコールを通知し、CPU のレジスタ(eax, ebx, ecx, ...)へそのパラメータをセットします。

- 例えばi386アーキテクチャでシステムコール番号5（open()の番号です）を通知する場合は、アプリケーションは int 命令を実行する前に、5 を eax レジスタにセットします。(さっきはWriteだったので4番)

- 例えばi386で5つまでのパラメータを渡す場合は、ebx、ecx、edx、esi、ediの各レジスタに、この順序でパラメータをセットします。

- 6つ以上のパラメータを使用する場合は、すべてのパラメータを格納したバッファ（ユーザ空間）へのポインタを1つセットします。

- **ほとんどのシステムコールは 2、3 のパラメータしか使用しません。**

---

### 1.1.2 Cライブラリ

- Cライブラリ（libc）はUnixアプリケーションの心臓部分です。
- Linux システムの C ライブラリは GNU libc です。glibc（ジーリブシー）
- GNU C ライブラリは多くの機能を備えています。標準 C ライブラリ関数だけではなく、glibc ではシステムコールラッパ、スレッド対応、アプリケーションで必要になる基本機能なども備えています。

Linuxに合わせてC言語を拡張している

---

### 1.1.3 Cコンパイラ

- Linuxでは、標準のCコンパイラはGNU Compiler Collection（gcc）です。
- 現在ではGNUコンパイラファミリの総称となっています。
- gccはCコンパイラを起動するコマンドの名前でもあります。

- 本書でgccと記述した場合は、通常はgccコマンドを指します。必要に応じ文脈から適宜判断してください。

---

## 1.2 API と ABI

- API（application programming interface）
- ABI（application binary interface）です。
- API も ABI も異なる種類のソフトウェア間のインタフェースを定義するものです。

---

### 1.2.1 API

- APIとは、ソフトウェア間のソースレベルでのインタフェースを定義したもの
- 他のソフトウェアから呼び出し可能なインタフェース(通常は関数)の標準セットを定義し、抽象化したものです。
- 双方のソフトウェアがAPIにしたがっている場合に限り、動作は保証され、ソースレベルの互換性が保たれます
- ３章 I/Oバッファリングでは標準入出力ライブラリを使用

---

### 1.2.2 ABI (1/2)

APIがソースレベルのインタフェースを定義するのに対し、ABIは特定のアーキテクチャにおけるソフトウェア間の低レベルなバイナリインタフェースを定義したものです。 アプリケーションが自身やカーネル、ライブラリと何らかの情報をやり取りする際に使用する方法です。

- ABIが保証するのはバイナリレベルの互換性（binary compatibility）です。

- ABIが定義するものは、**呼び出し規約（calling convention）、バイトオーダ、レジスタの使用、システムコールの発行、リンク、ライブラリの動作、バイナリオブジェクト形式など** です

例えば、**呼び出し規約** では、次のような内容を定義します。

- 関数コールの方法
- 関数パラメータの渡し方
- 値が維持される、またはされないレジスタ
- 関数の戻り値の受け取り方

---

### 1.2.2 ABI (2/2)

1つのアーキテクチャに対しては1つのABIを策定し、複数の異なるオペレーティングシステム間で共有する試みがこれまでに何度かなされましたが失敗した

ほぼすべてのABIは、レジスタやアセンブリ命令など、マシン固有の実装に依存します。このため、LinuxでもマシンアーキテクチャごとにそれぞれのABIを定義しています。

#### Wikipediaより

ABIには、以下のような定義が含まれる。

- CPU - 命令セット、エンディアンなど。
- データ - データ型、大きさ、配置（アラインメント）など。
- 呼出規約 - 関数の引数がどのように渡され、リターン値がどのように渡されるかを定義したもの。
- システムコール - システムコール番号と具体的なシステムコールの仕組み。
- 実行ファイルやライブラリの詳細なフォーマット（UNIXならば、COFFやELFなど）。

---

## 1.3 標準仕様

- 技術的に言えば Linux はどの標準にも正式にはしたがっていません。
- Linux ではもっとも重要でかつ普及している 2 つの標準に準拠することを目標にしています。
  - POSIX （Portable Operating System Interface）
  - SUS（Single UNIX Specification）

### 1.3.1 POSIX と SUS の歴史

- POSIX（パーズィックスと読みます†）
  - †国内ではポズィクス、ポジックスという読み方が多いようです。

1990年代初頭の Unix Wars の最中に、The Open Group が SUS（Single UNIX Specification）を公開すると、急速に普及しました。大きな要因は POSIX 標準が有償で高くつくのに対し、SUS は無償で入手可能だったためです。今日の SUS では最新の POSIX 標準を取り込んでいます。

**本書でシステムコールや他のインタフェースがPOSIXで標準化されていると述べる場合は、SUS ではなく POSIX を指します。SUS が POSIX を包含しているためです。**

---

### 1.3.2 C言語仕様

 Dennis Ritchie と Brian Kernighan の著名な『The C Programming Language』（Prentice Hall 刊、邦題『プログラミング言語 C』共立出版刊）は、1978 年の出版以来、非公式ながらも C 言語の標準仕様と位置付けられていました。