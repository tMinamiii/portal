---
marp: true
theme: gaia

---

# 1章 概要および主要概念

<style>
{
font-size: 22px;
}
</style>

- 本書はシステムプログラミング（system programming）、すなわちシステムソフトウェア（system software） 開発の真髄を解説するものです
- GUI アプリケーションなど他のソフトウェアはほとんどがより上位に位置し、下位のソフトウェア、ハードウェアへアクセスすることは極めてまれか、もしくは全くありません
- 上位(GUI)のシステム概念の単なる土台になるのがシステムプログラミングです
- システムプログラミングに対する理解はすべてのプログラマに必須と言えます

- Linus Torvalds、Linuxを作った人(gitも)
[![Image from Gyazo](https://i.gyazo.com/81a46bb3d011bc133514477914987640.jpg)](https://gyazo.com/81a46bb3d011bc133514477914987640)

---

## 1.1 システムプログラミング

本書はこの疑問および以下のような疑問に答えるためのものです。

- Linux でシステムレベルのアプリケーションを開発するにはどうすれば良いか。
- カーネルや C ライブラリが提供するものは具体的に何か。
- 効率的なソースコードを記述するには、また Linux ではどんな仕掛けが用意されているか。
- 他のUnixシステムと比べて、Linuxではどんな巧妙なシステムコールが用意されているか。また、どんな動作をするのか。

Linux のシステムプログラミングでは重要なものが 3 つあります。
- システムコール
- C ライブラリ
- C コンパイラです。
まずそれぞれについて概要をまとめます。

---

### 1.1.1 システムコール

システムコールとは、ユーザー空間からOSに何らかの動作やリソースを要求するための、カーネル機能を呼び出す物

- read(): ファイルディスクリプターから読み込む
- write(): ファイルディスクリプター (file descriptor) に書き込む
- get_thread_area(): スレッド局所記憶領域を取り出す
- set_tid_Address(): thread IDのポインタを設定する ?

---

### ファイルディスクリプタとは？

> ファイル（への通り道）に割り振られる番号で、ファイルを識別するための目印

 ([「分かりそう」で「分からない」でも「分かった」気になれるIT用語辞典](https://wa3.i-3-i.info/word14383.html)) より


>プログラムが特定のファイルを指定して「開く」操作を行うと、カーネル内のファイルテーブルと呼ばれる領域に対応する項目が作成され、対象ファイルのストレージ上での位置（パス）、ファイル内の現在の操作位置などの情報が記録される。

>このテーブル内での当該ファイルの識別番号がファイルディスクリプタで、以降はプログラムからファイルディスクリプタを指定して、どのファイルへの操作なのかをカーネルに伝達する。

>通常、ファイルディスクリプタは0から順番に未使用の最も小さい値が与えられるようになっており、プログラム上では整数型の変数などとして扱われる。ただし、番号によっては固定的に特殊な対象を表す場合があり、一般的には「0」は標準入力（stdin）、「1」は標準出力（stdout）、「2」は標準エラー出力（stderr）としてプログラムの実行中は常に開いた状態になっている。

([IT用語辞典 e-Words](https://e-words.jp/w/%E3%83%95%E3%82%A1%E3%82%A4%E3%83%AB%E3%83%87%E3%82%A3%E3%82%B9%E3%82%AF%E3%83%AA%E3%83%97%E3%82%BF.html))

---

### スレッド局所記憶領域(thread local storage, TLS)

- グローバル変数がプロセスごとに割り当てる変数
- スレッドローカル変数はスレッドごとの領域に割り当てられています。その領域をスレッドローカルストレージという
    - errno: errnoは、マルチスレッドという概念が導入される前のもの。スレッドローカルにしないと各スレッドでのシステムコール呼び出しの結果で errno が上書きされるという事故に繋がります

---

#### 1.1.1.1 システムコールの発行(コール)  1/3

- ユーザーアプリケーションが直接的にカーネル内のコードを実行したり、データを操作することは禁止されている

- カーネル定義した方法にしたがって、アプリケーションからカーネルへ入り(trap)許可された範囲でカーネルコードを実行
    - /kernel/traps.c: 割込みハンドラとしてシステムコールが登録されている

- i386(32bit)システムでは、ユーザーアプリケーションがソフトウェア割り込み命令**int**(interrupt ?) を実行します。割り込み番号は 0x80 (`int 0x80`という命令が実行される)。

- 割り込み番号は `0x80`(int 0x80。この割り込み命令によりカーネル空間、すなわち**ソフトウェア割り込みハンドラを実行するカーネル内の保護された空間**へと切り替わりる。

---

#### 1.1.1.1 システムコールの発行(コール)  2/3 (アセンブリ言語 Ubuntu20.04)

<style>
pre > code {
  font-size: 17px;
}
</style>

```assembly
.globl _start
_start:
    /* $の後が数字なら数字、文字なら変数。%はレジスタ */
    movl $4,%eax   /* write システムコール番号 */
    movl $1,%ebx   /* 書き込み先 - 標準出力 */
    movl $msg,%ecx /* 書き込むメッセージ */
    movl $13,%edx  /* メッセージの長さ */
    int $0x80      /* システムコール実行 割り込み実行 */

    movl $1,%eax /* システムコール終了番号 */
    movl $0,%ebx /* 終了状態 */
    int $0x80    /* システムコール終了 割り込み実行 */

.data
    msg: .asciz "Hello,World\n"
```

```sh
➜ ~ as -o main.o main.S
➜ ~ ld -o main.out main.o
➜ ~ ./main.out
hello,World
➜ ~
```

- [アセンブリコードで「int0x80」とはどういう意味ですか？](https://codehero.jp/assembly/1817577/what-does-int-0x80-mean-in-assembly-code)
- [さくっとアセンブリ入門 hello,world編](https://rabbitfoot141.hatenablog.com/entry/2016/05/01/124410)

---

#### 1.1.1.1 システムコールの発行(コール)  3/3 (C言語)

```c
#include<unistd.h>

int main(){
  const void *string = "Hello,World!\n";
  write(1, string, 13);
  return 0;
}
```

```sh
➜ ~ gcc write.c
➜ ~ ./a.out
Hello World!
➜ ~
```

---

#### (おまけ) 1.1.1.1 システムコールの発行(コール)  3/3

```assembly
int main(){
   0:   f3 0f 1e fa             endbr64
   4:   55                      push   %rbp
   5:   48 89 e5                mov    %rsp,%rbp
   8:   48 83 ec 10             sub    $0x10,%rsp
  const void *string = "Hello Write!\n";
   c:   48 8d 05 00 00 00 00    lea    0x0(%rip),%rax        # 13 <main+0x13>
  13:   48 89 45 f8             mov    %rax,-0x8(%rbp)
  write(1, string, 13);
  17:   48 8b 45 f8             mov    -0x8(%rbp),%rax
  1b:   ba 0d 00 00 00          mov    $0xd,%edx
  20:   48 89 c6                mov    %rax,%rsi
  23:   bf 01 00 00 00          mov    $0x1,%edi
  28:   e8 00 00 00 00          callq  2d <main+0x2d>
  return 0;
  2d:   b8 00 00 00 00          mov    $0x0,%eax
}
  32:   c9                      leaveq
  33:   c3                      retq
```

---

#### 1.1.1.1 システムコールの発行(コール)  3/3

- アプリケーションはカーネルに対し、実行するシステムコールを通知し、CPU のレジスタ(eax, ebx, ecx, ...)へそのパラメータをセットします。

- 例えばi386アーキテクチャでシステムコール番号5（open()の番号です）を通知する場合は、アプリケーションは int 命令を実行する前に、5 を eax レジスタにセットします。(さっきはWriteだったので4番)

- 例えばi386で5つまでのパラメータを渡す場合は、ebx、ecx、edx、esi、ediの各レジスタに、この順序でパラメータをセットします。

- 6つ以上のパラメータを使用する場合は、すべてのパラメータを格納したバッファ（ユーザ空間）へのポインタを1つセットします。

- **ほとんどのシステムコールは 2、3 のパラメータしか使用しません。**

---

### 1.1.2 Cライブラリ

- Cライブラリ（libc）はUnixアプリケーションの心臓部分です。
- Linux システムの C ライブラリは GNU libc です。glibc（ジーリブシー）
- GNU C ライブラリは多くの機能を備えています。標準 C ライブラリ関数だけではなく、glibc ではシステムコールラッパ、スレッド対応、アプリケーションで必要になる基本機能なども備えています。

Linuxに合わせてC言語を拡張している

---

### 1.1.3 Cコンパイラ

- Linuxでは、標準のCコンパイラはGNU Compiler Collection（gcc）です。
- 現在ではGNUコンパイラファミリの総称となっています。
- gccはCコンパイラを起動するコマンドの名前でもあります。

- 本書でgccと記述した場合は、通常はgccコマンドを指します。必要に応じ文脈から適宜判断してください。

---

## 1.2 API と ABI

- API（application programming interface）
- ABI（application binary interface）です。
- API も ABI も異なる種類のソフトウェア間のインタフェースを定義するものです。

---

### 1.2.1 API

- APIとは、ソフトウェア間のソースレベルでのインタフェースを定義したもの
- 他のソフトウェアから呼び出し可能なインタフェース(通常は関数)の標準セットを定義し、抽象化したものです。
- 双方のソフトウェアがAPIにしたがっている場合に限り、動作は保証され、ソースレベルの互換性が保たれます
- ３章 I/Oバッファリングでは標準入出力ライブラリを使用

---

### 1.2.2 ABI (1/2)

APIがソースレベルのインタフェースを定義するのに対し、ABIは特定のアーキテクチャにおけるソフトウェア間の低レベルなバイナリインタフェースを定義したものです。 アプリケーションが自身やカーネル、ライブラリと何らかの情報をやり取りする際に使用する方法です。

- ABIが保証するのはバイナリレベルの互換性（binary compatibility）です。

- ABIが定義するものは、**呼び出し規約（calling convention）、バイトオーダ、レジスタの使用、システムコールの発行、リンク、ライブラリの動作、バイナリオブジェクト形式など** です

例えば、**呼び出し規約** では、次のような内容を定義します。

- 関数コールの方法
- 関数パラメータの渡し方
- 値が維持される、またはされないレジスタ
- 関数の戻り値の受け取り方

---

### 1.2.2 ABI (2/2)

1つのアーキテクチャに対しては1つのABIを策定し、複数の異なるオペレーティングシステム間で共有する試みがこれまでに何度かなされましたが失敗した

ほぼすべてのABIは、レジスタやアセンブリ命令など、マシン固有の実装に依存します。このため、LinuxでもマシンアーキテクチャごとにそれぞれのABIを定義しています。

#### Wikipediaより

ABIには、以下のような定義が含まれる。

- CPU - 命令セット、エンディアンなど。
- データ - データ型、大きさ、配置（アラインメント）など。
- 呼出規約 - 関数の引数がどのように渡され、リターン値がどのように渡されるかを定義したもの。
- システムコール - システムコール番号と具体的なシステムコールの仕組み。
- 実行ファイルやライブラリの詳細なフォーマット（UNIXならば、COFFやELFなど）。

---

## 1.3 標準仕様

- 技術的に言えば Linux はどの標準にも正式にはしたがっていません。
- Linux ではもっとも重要でかつ普及している 2 つの標準に準拠することを目標にしています。
  - POSIX （Portable Operating System Interface）
  - SUS（Single UNIX Specification）

### 1.3.1 POSIX と SUS の歴史

- POSIX（パーズィックスと読みます†）
  - †国内ではポズィクス、ポジックスという読み方が多いようです。

1990年代初頭の Unix Wars の最中に、The Open Group が SUS（Single UNIX Specification）を公開すると、急速に普及しました。大きな要因は POSIX 標準が有償で高くつくのに対し、SUS は無償で入手可能だったためです。今日の SUS では最新の POSIX 標準を取り込んでいます。

**本書でシステムコールや他のインタフェースがPOSIXで標準化されていると述べる場合は、SUS ではなく POSIX を指します。SUS が POSIX を包含しているためです。**

---

### 1.3.2 C言語仕様 (雑学)

- Dennis Ritchie と Brian Kernighan の著名な『The C Programming Language』（Prentice Hall 刊、邦題『プログラミング言語 C』共立出版刊）は、1978 年の出版以来、非公式ながらも C 言語の標準仕様と位置付けられていました。

- 1995 年には ISO は C 言語を改版し、ISO C95（あまり普及していません）を、さらに 1999 年には大幅な更
新を加えたISO C99を公開しました。ISO C99にはインライン関数、データ型の拡張、可変長配列、C++言語のコメント形式、新たなライブラリ関数など多くの機能が追加されています。

---

### 1.3.3 Linuxと標準仕様 (POSIX, SUS) (雑学)

- Linux では POSIX および SUS に準拠することを念頭に置いています。
- さらに重要な点は、Linux が POSIX と SUS が要求する通りの動作を実装しようと努めていることで、標準に準拠していない動作は全般的にバグと見做されます。
- 現在のLinuxがPOSIX.1および SUSv3 に準拠していることは間違いないと思われますが、POSIX または SUS の公的な認証は受けていません（すべてのバージョンの Linux がそうです）。Linux が POSIX や SUS に正式に準拠していると言うことはできません。
- これまでの Linux は互換性に関してはそれほど優秀とは言えませんでしたが、最近ではだいぶ改善されました。
- 重要な点は、Linuxカーネルがシステムコールの安定性を保証していることです。システムコールが Linux カーネルの安定バージョンに実装されれば、その存在は今後も保証されます。

---

### 1.3.3 Linuxと標準仕様 (LSB) (雑学)

 Linuxシステムの多くの部分を標準化したLSB（Linux Standard Base）はさまざまなLinuxディストリビュー
ションで採用されています。LSBは、Linux Foundation（正式にはFree Standards Group）が後援する複数の
Linuxベンダからなるジョイントプロジェクトで策定され、POSIXとSUSを拡張し独自の標準を追加したも
のです。LSB準拠のシステムならばオブジェクトコードを変更せずとも動作可能なように、バイナリレベル
の標準化も目標としています。大半のLinuxベンダが完全とは言わなくともある程度はLSBに準拠しています。

---

### 1.3.4 本書での標準仕様の扱い (補足)

- 本書ではLinuxカーネルの最新バージョン（2.6）、gcc Cコンパイラ（4.2）、Cライブラリ（2.5）を使用した、現代の Linux システムにおけるシステムプログラミングに集中します。
  - 2007年のお話、Ubuntu20.04だとKernel(5.10)、gcc(9.3) glibc(2.30)

- Linuxカーネルでは、システムインタフェースは通常変更されることはありませんし、またソースレベル、バイナリレベルの両方で、完全とはいかなくとも、互換性を維持します。Linuxカーネル開発者達は、システムコールインタフェースを維持するように多大な努力を注いでいます。この方針のおかげで、多数のUnixシステムや標準との互換性という足枷を引きずることなく、Linuxのシステムインタフェースの詳細に踏み込むことができますし、同時にまたLinuxの最新のインタフェースを詳細に解説する本書が、インタフェースが変更され時代遅れになることなく将来に渡っても通用するものになります。本書は、Linuxの高度な知識、特にgccやカーネルのなどの実装や動作に関する知識に基づき、経験豊富な開発者の視点から実践的で最良な技を満載しています。

---

## Linuxプログラミングの概念 (ここから本題)

- 本節ではLinuxシステムのサービスの概要を簡潔にまとめます。Linuxを含むすべてのUnixシステムは共
通の概念とインタフェースを備えており、これこそが実際の Unix の定義とも言えます。ファイルやプロセ
スの概念、パイプやソケットの操作インタフェースなどは、Unix とは何かを示す中核にあります。

- 本書では読者がLinux環境にすでに慣れ親しんでいることを前提としています。シェルや基本的なコマン
ドを問題なく操作でき、C言語で記述された単純なソースファイルもコンパイルできるレベルです。

- 本書は Linux の概要やプログラミング環境について述べたものではなく、Linux システムプログラミングの基本的
な「技」を解説したものです。

---

### 1.4.1 ファイルとファイルシステム

ファイルは Linux の中でももっとも基本的かつ重要な概念です。Linux には **すべてのものはファイルである（everything-is-a-file）** という思想があります。

- ファイルにアクセスするにはまずオープンする必要があります。
- 読み取り専用、書き込み専用、またはその両方が可能なようにオープンできます。
- オープンしたファイルを使用する際にはディスクリプタを使用します。
- ディスクリプタは一意な識別子で、オープンしたファイルのメタデータ(ファイルの内容以外の、ファイルに関する情報)とファイルを対応させるものです。
- Linux カーネル内部では、ディスクリプタは整数（C 言語の int 型）で表現され、ファイルディスクリプタ（ファイル記述子、file descriptor）または省略してfdと呼ばれます。
- ファイルディスクリプタはユーザ空間と共有され、アプリケーションがファイルへアクセスする際に使用されます。Linuxシステムプログラミングの多くの部分は、ファイルディスクリプタを使用したファイル操作やオープン / クローズです。

---

#### 1.4.1.1 通常ファイル 1 (ファイルについて)

- 一般に「ファイル」と呼ぶものは、Linux では通常ファイル（レギュラファイル、regular file）と名付けています。
- ファイルはバイトがリニアに並んだデータ（バイトストリーム、バイト列、byte stream）を持っています。
- **Linuxのファイルにはこの構造しかありません。**
- バイトは任意の値を持てますし、ファイル内ならばどの位置にでも配置できます。システムレベルで考えると、Linuxがファイルに対しバイトストリーム以外の構造を使用することはありません。
  - **VMS** など他のオペレーティングシステムでは、レコード（record）などの高度に構造化されたファイルを備えているものもありますが、Linuxにはありません。

Wikipediaより
> OpenVMS (Open Virtual Memory System) は、DECによって設計された、タイムシェアリングシステム、バッチ処理およびトランザクション処理用のオペレーティングシステムである。当初は単にVMSと一般的には呼ばれており...

---

#### 1.4.1.1 通常ファイル (ファイルポジションと書き込み)

- ファイル内のバイトは読み取りまたは書き込みが可能です。読み書きは指定されたバイトから開始します。
- この開始バイトはファイル内の「位置」と考えられ、ファイルポジション（file position）またはファイルオフセット（file offset）と言います。
- ファイルが初めてオープンされた時のファイルポジションは0です。
- 通常はバイトごとにファイルを読み書きするため、ファイルポジションはその量に応じて自動的に増加します。
- 明示的にファイルポジションを移動することも可能です。
- 実際のファイルサイズよりも大きなファイルポジションへも移動可能です。ファイル終端を越えた位置にデータを書き込むと、**終端から書き込み位置までには0が埋め込まれます。**
- ファイルの先頭よりも**前の位置に書き込むことはできません。**(そんな用途もない)
- 終端までの範囲内でファイルに書き込むと、それまでその位置にあった**バイトデータは上書き**されます。
- このため、終端までの範囲内での書き込みよりファイルサイズが増加することはありません。ファイル書き込みの多くはファイル終端で行われます。
- ファイルポジションの最大値は、ファイルポジションを代入する C言語の型のサイズにより制限され、現在の Linux では 64 ビット型を使用しています。

---

#### 1.4.1.1 通常ファイル (ファイルのサイズとトランケート)

- ファイルのサイズはバイト単位で表現し、ファイルサイズ（レングス、length）と呼びます。
  - length = ファイルを構成するバイトストリームのバイト数です。
- トランケート（トランケーション、切り詰め、truncation）操作を行うと、ファイルサイズを変更できます。
- **元のサイズよりも小さなサイズへトランケートした場合は、新しいサイズ以降のバイトは削除されます。**
- **元のサイズよりも大きなサイズへトランケートした場合は、元のサイズ以降には 0 が埋められます。**
- **ファイルを空にもできます。** サイズが0のファイルでバイトストリームが存在しないものです。
- ファイルサイズの最大値は、ファイルポジションの最大値と同様に、Linuxカーネルがファイル管理に使用している**C言語の型に依存**します。
  - しかし、**ファイルシステムによっては、独自の制限を加え、より小さいサイズにしている**ものもあります。

---

#### 1.4.1.1 通常ファイル (同じファイルでも複数回オープン)

- 同じファイルでも複数回オープンすることができます。
- 同じプロセスからでも、また異なるプロセスからでも可能です。
- オープンしたファイルインスタンスには一意のファイルディスクリプタが割り振られ、複数のプロセス間で同じファイルディスクリプタを共有することも可能です。
- **カーネルは同時に行われるファイルアクセスに対しなんら制限を加えません。**
- 複数のプロセスが同じファイルに対し、同時に読み書き可能です。
- 同時アクセスの結果は、それぞれの操作が行われた順序に依存し、通常は予測不可能です。
- 同時アクセスの同期を取る必要がある場合は、通常はアプリケーションで処理します。

---

#### 1.4.1.1 (ファイルへアクセスとinode)

ファイルへアクセスする際にはファイル名（filename）を使用するのが常ですが、**実はファイル名は直接にはファイルに対応していません。**

- ファイルに実際に対応し、参照の際に使用されるのはinode（アイ-ノード、 iノード。もともとはinformation nodeまたはindexed node）であり、一意な数字が割り振られています。
- inodeには、更新時刻、オーナ、種類、サイズなどの、ファイルに対応するメタデータが保存されています。
- ファイルの内容（ファイルデータ）のディスク上の保存位置もinodeが保持します。 **しかしファイル名は持っていません。**
- inodeはUnixのファイルシステムのディスク上に存在する物理的なオブジェクトであると同時に、Linuxカーネル内のデータ構造を表す論理的なエンティティでもあります。

---

### 1.4.1.2 ディレクトリとリンク 1

- inode番号を使用したファイルアクセスは手間がかかります（その上、セキュリティホールにもなるでしょう）。
- このため、ユーザ空間からのファイルオープンは、inode番号ではなく、常にファイル名を使用します。
- アクセスするファイルのファイル名を保持しているのはディレクトリ（directory）で、可読性と操作性で有利なファイル名と inode 番号とを対応付けます。
- **ファイル名と inode の組をリンク（link）と言います。**
- リンクのディスク上の物理的な実装は、単純なテーブルやハッシュテーブルなど、ファイルシステムによりさまざまな形式があります。
- 概念としてのディレクトリは他のファイルと同じように見えますが、その内容としてファイル名とinode番号の組のみを持つ点が異なります。
- カーネルはディレクトリに保存された組をもとに、ファイル名を inode 番号へ変換します。

---

### 1.4.1.2 ディレクトリとリンク 2

- ユーザアプリケーションがファイル名を指定しファイルオープンを要求すると、カーネルは対象ファイル名を持つ親ディレクトリをオープンし、指定されたファイル名を検索します。
- さらにファイル名からinode番号を、inode番号から inodeを特定します。
- inodeにはファイルに対応するメタデータが保存されており、ファイルの内容を保存したディスク上の位置などの情報が得られます。
- 初期状態としては、ディスク上にはディレクトリ 1 つしか存在しません。ルートディレクトリ（root directory）です。
- ルートディレクトリは通常/（スラッシュ）というパスで表されます。
- しかし実際のシステムには多数のディレクトリが存在するのが常です。ファイル名を与えられた場合に、カーネルはどのように検
索する親ディレクトリを特定できるのでしょう。

---

### 1.4.1.2 ディレクトリとリンク 3

- すでに述べましたが、ディレクトリと通常ファイルの差異は大きくありません。**両者ともに対応するinodeを持っています。**
- このため、ディレクトリ内のリンクから他のディレクトリのinodeを得られます。
- すなわち、**ディレクトリは他のディレクトリ内に入れ子状に存在し、ディレクトリ階層を構成します。**
- この構造のおかげで、Unix ユーザが普段から使用している /home/blackbeard/landscaping.txt のようなパス名（pathname）が使用可能となります。